# 聊聊游戏开发与动画利器 raf

今年下半年打算正式撸一撸小游戏，正好这些天整理一下有关游戏的一些知识，当然了，目前还是打算使用浏览器网页进行游戏开发。 

## 网页游戏开发的优势与未来

如果使用其他语言开发游戏，无论游戏本身大小与否，我们都需要游戏引擎来帮助我们构建开发，而对于浏览器来说，我们在开发小游戏时候，利用浏览器本身提供的组件和 api 就可以直接进行业务处理反而是更加简单的，我们也可以更加高效的学习与实践游戏逻辑。同时网页游戏的构建与发布也非常简单。

例如像 [**Js13kGames** ](http://js13kgames.com/) (Js13kGames是一个针对 HTML5游戏开发者的 JavaScript 编码竞赛,该竞赛的有趣之处在于将文件大小限制设置为13 kb ) 这样的限制代码量的游戏开发竞赛。对于非网页游戏开发来说，这基本上是不可能完成的，因为它们不具备有像浏览器这种量级的通用型的工具。

随着时间的发展，浏览器的功能，性能也在不断提升。通过 WebGL, WebAssembly 各种层出不穷的技术。让很多之前想都不敢想的功能在浏览器上实现。同时,伴随着 5G 到来，网速的提升，想必网页游戏可以到达更高的层次。

当然了，事实上，游戏开发需要很多的组件，包括数学库，碰撞及物理，音频，资源管理等等等等，不过在浏览器下，这些组件都可以做到按需引用。

## 游戏循环架构与风格

所谓游戏循环，就是不间断，基于时间和逻辑不断更新数据以及重绘界面。核心一定会有至少一个或者多个循环。

### 视窗消息泵

在 Windows 平台中，游戏除了需要对自身进行服务外，还需要处理来自于 Windows 系统本身的消息，因此，Windows中有游戏都会有一段被称为**消息泵**的代码。其原理是先处理 Windows 的消息，之后再处理游戏循环逻辑。

```c
// 不断循环处理
while (true) {
  MSG msg;
  
  // 如果当前消息队列中有消息，取出消息
  while(PeekMessage(&msg, NULL, 0, 0) > 0) {
      TranslateMessage(&msg);
      DispatchMessage(&msg)
  }
  
  // 执行游戏循环，类似于更新与重绘
  RunGame()  
}
```

以上代码的副作用在于设置了游戏处理消息的的优先级，循环中先处理 Windows  消息。如果游戏再调整或者移动视窗时候，游戏就会愣住不懂。

## 回调驱动

很多游戏框架(包括浏览器)已经在内部实现了主游戏循环，我们无法直接介入内部循环机制，我们只需要编写回调函数填充细节即可。

类似于浏览器页面是由消息队列和事件循环来驱动的。而浏览器提供的回调就包括 **setTimeout**(延迟执行) 与 **setInterval **(间隔执行)( **requestAnimationFrame** 后面再说)。

setTimeout 是一个定时器，用来指定某个函数在多少毫秒之后执行。他会返回一个编号，表示当前定时器的编号，同时你也可通过 clearTimeout 加入编号来取消定时器的执行。

```js
// 注册 10 ms 后打印 hello world
const id = setTimeout(() => {
  console.log('hello world')
}, 10)

clearTimeout(id)
```

也就是在消息**循环**中不断执行任务,当发现延迟任务队列中的某个任务超过了当前的时间节点时候(通过发起时间和延迟时间来计算)，就直接取出任务执行调用。等到期的任务都执行完成后，在进行下一个循环过程，通过这样的方式，一个完整的定时器就实现了。浏览器取消定时器则是通过 id 查找到对应的任务，将任务从队列中删除。

请注意: 浏览器为了优化后台页面的加载损耗以及降低耗电量，会让没有激活的浏览器标签执行间隔大于 1000 ms。

我们也可以通过多次执行自身来实现间隔执行，看起来也类似于间隔执行，其实还是会有一定的区别。

```
// 在回调函数完成后才去设置定时器，时间会超过 16 ms
setTimeout(function render(){
  // 执行需要 6 ms
  // 定时 16ms 后
  console.log(+ new Date())
  setTimeout(render, 500);
}, 500)

// 尝试每 16 ms 执行一次，不管内部回调函数耗时
setInterval(function render(){
  
}, 16)
```

重点在于，JavaScript 本身是单线程的，无法切断当前任务的执行，我们只能够控制定时器何时能够加入队列，无法控制何时执行，如果其他事件执行的时间过久的话，定时器任务就必须延后执行，也就没有办法。 当然了，社区的力量也是无穷的， React Fiber 也实现了中断当前任务，执行优先级更高的任务的功能。

不过像使用浏览器的系统(包括游戏等)都是软实时系统。所谓软实时系统，就是即使错过限定期限也不会造成灾难性后果——错过了当前帧数，现实世界不会因此造成灾难性后果，于此相比，航空电子，核能发电等系统都属于是硬实时系统，错过期限会有严重的后果。不过谁会喜欢一个经常卡顿的系统呢？所以对于系统来说，提升性能还是重中之重。

当然了， requestAnimationFrame 也是回调，那么它有什么过人之处让



## 屏幕刷新率与 FPS

屏幕刷新率即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是 60Hz，在  Window 10 上 可以通过桌面上**右键->显示设置->高级显示设置** 中查看和设置。屏幕刷新率表示显示器的物理刷新速度。

![image-20200512223617840](C:\Users\wsafight\AppData\Roaming\Typora\typora-user-images\image-20200512223617840.png)

对于我的电脑来说，无论我目前是在浏览网页或者什么也不做，当前显示器也以 1 秒刷新 165 次当前的界面，该数值取决于显示器。我们也可以通过修改**适配器属性->监视器**来调整屏幕刷新率,一般来说，我们只要调整到眼睛舒适即可。

仅仅靠浏览器高频的刷新率是没用的，我们还需要电脑

不知道大家在小学的时候有没有买果或者玩过翻纸动画？如果你没有了解过，也可以看一看bilibili 中的视频 [高中生自制的翻纸动画短片]( https://www.bilibili.com/video/av24463374/?p=2)。视频中通过快速翻动纸张来实现两个火彩人打架的精彩动画。事实上，我们的电脑，手机设备能够展示都是基于此原理。

当物体在快速运动时, 人眼所看到的影像消失后，人眼仍能继续保留其影像1/24秒左右的图像，这种现象被称为视觉暂留现象。是人眼具有的一种性质。人眼观看物体时，成像于视网膜上，并由视神经输入人脑，感觉到物体的像。但当物体移去时，视神经对物体的印象不会立即消失，而要延续1/24秒左右的时间，人眼的这种性质被称为“眼睛的视觉暂留”。

该特性也就是我们所说的 FPS 每秒传输帧数(Frames Per Second).

**网页动画的每一帧（frame）都是一次重新渲染。**每秒低于24帧的动画，人眼就能感受到停顿。**一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。**如果能达到每秒70帧甚至80帧，就会极其流畅。

## requestAnimationFrame (Raf) 作用与目的

虽然 高效的运行也是必要的

在显卡中有一块叫着前缓冲区的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是 60HZ，也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区。如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU 会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到 GPU 中最新的图片。这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，如下图所示：VSync 时钟周期和渲染引擎生成图片不同步问题这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在 100fps 而刷新率只有 60Hz 的时候，GPU 所渲染的图像并非全都被显示出来，这就会造成丢帧现象。就算屏幕的刷新频率和 GPU 更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的。所以 VSync 和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来，Chromium 也是这样实现，那么下面我们就来看看 Chromium 具体是怎么实现的？当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU，简称 VSync。这时候浏览器就会充分利用好 VSync 信号。

当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU，简称 VSync。这时候浏览器就会充分利用好 VSync 信号。

定时器

##  

设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。

我们知道 CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。

但是 JavaScript 是由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 window.requestAnimationFrame，用来和 VSync 的时钟周期同步，那么我留给你的问题是：你知道 requestAnimationFrame 回调函数的执行时机吗？



但是 JavaScript 是由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的





如果你打大型单机游戏或者你的电脑有些



## requestAnimationFrame 特性

一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力，requestAnimationFrame  会不断下降，同理 requestIdea 也是如此。

对于






所以如果需要 js 动画，我们需要定时器回调来实现动画效果。

定时器





requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。

不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。

requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用。

requestAnimationFrame 是为了更好的渲染动画而提出的，他的调度完全取决于浏览器的渲染等因素，如果你需要做其它功能性操作，定时器仍旧是更好的选择。

## 



### 其他

[《游戏引擎架构》](https://book.douban.com/subject/25815142/)

https://blog.csdn.net/vhwfr2u02q/article/details/79492303

https://www.sohu.com/a/325643652_120099902



https://docs.google.com/document/d/16822du6DLKDZ1vQVNWI3gDVYoSqCSezgEmWZ0arvkP8/edit
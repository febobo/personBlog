# 聊聊 js 引擎内数组排序实现

在开发 web 应用的过程中，会遇到这样或者那样的问题。对我而言，其中有很多问题是对文档解读不够所致。当然也会有少许属于开发工具或者生成工具的问题。因为无可避免，可能对于设计与思想不够周到所致。

我在之前的工程代码中需要构建新的数据结构，但是由于后端给与数据与所需结构不符，需要对数据重新排序之后之后进行处理。但是该程序在某些浏览器下会出现数据混乱的情况。所以这里我们就来聊一聊当前 js 引擎数组排序的实践(注明: 以下所有的问题与解读仅仅代表当前的状态，随着时间的推移，问题也必然发生变化)。

## 排序的稳定性

说到算法，第一个想到的便是时间复杂度，第二个则是空间复杂度。前者决定了性能，后者则是内存消耗。但是对于排序算法而言，稳定性却不可不谈。即在经历过一次排序，所得到的数据与排序之前的数据相对位置不变。

这里做个简单的代码说明:
```
function getObjs(len) {
  const datas = []
  for(let i=0;i < len; i++) {
    datas.push({
      index: parseInt(i / 10),
      data: i
    })
  }
  return datas
}

var arr = getObjs(20)
// 可以得到 {index: 0, data: 0 ~ 9}, {index: 1, data: 10 ~ 19}
[
  {index: 0, data: 0},
  {index: 0, data: 1},
  ...
  {index: 0, data: 9},
  {index: 1, data: 10},
  ...
  {index: 1, data: 19},
]
```

简单起见，我们使用冒泡排序来示范, 冒牌排序是一个稳定性的算法，比较相等的元素保持其原始顺序。

```
// 简单起见，不做防御式代码
function bubbleSort(arr) {
  for(let i = 0; i < arr.length;i++) {
    for(let j = 0; j < arr.length - i -1;j++) {
      if (arr[j + 1].index > arr[j].index) {
        // 交换数据的快速写法,详见es6数组结构赋值
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
      }
    }
  }
}

// 可以得到 {index: 1, data: 10 ~ 19}， {index: 0, data: 0 ~ 9}
[
  {index: 1, data: 10},
  {index: 1, data: 11},
  ...
  {index: 1, data: 19},
  {index: 0, data: 0},
  ...
  {index: 0, data: 9},
]
```

稍微修改一下冒泡排序,把 > 改为 >=

```
function bubbleSort(arr) {
  for(let i = 0; i < arr.length;i++) {
    for(let j = 0; j < arr.length - i -1;j++) {
      // 注意,在 if 判断中，修改了条件，即使相等，也要互换位置
      if (arr[j + 1].index >= arr[j].index) {
        // 交换数据的快速写法,详见es6数组结构赋值
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
      }
    }
  }
}

// 可以得到 {index: 1, data: 19 ~ 10}， {index: 0, data: 9 ~ 0}
[
  {index: 1, data: 19},
  {index: 1, data: 18},
  ...
  {index: 1, data: 10},
  {index: 0, data: 9},
  ...
  {index: 0, data: 0},
]
```
我们可以看出，第一个算法是稳定的，虽然是根据 index 排序，但是最终的排序还是之前data顺序的影子，第二个则是不稳定的算法(即使相等也要互换位置，不可能稳定)。

稳定的算法价值就在于此。在拥有后一个排序规则，依然受到前一个排序规则的影响。   
- 如果排序数组内部的仅仅只为基本类型，稳定不稳定无所谓。   
- 如果排序数组是对象
  - 对象内部的规则唯一(每个规则所代表的数据仅仅只有一个,如工号)。则按照此项排序不需要在乎前一个规则。
  - 对象内部规则不为一(比如说人类的年龄，物品的 sku 属性)。需要稳定性排序。

从某种意义上来讲，我们在遇到 也就是说，在一些 js 引擎上实现的 Array.prototype.sort 是不稳定的，那么他是bug吗？是不对的吗？
我们来查看一下 ecmasciprt 语言规范。

## js标准化规范

今年已经是2019。详情可见 [ECMAScript® 2019 Language Specification](https://www.ecma-international.org/ecma-262/10.0/index.html)，可以直接去查询 Array.prototype.sort 方法的标准。

The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x < y, zero if x = y, or a positive value if x > y.

我们可以看出，第二句话就表明了，排序必须是稳定的（即，比较相等的元素必须保持其原始顺序）。我们确认了，在最新应用的版本(还有明年的提案版本)中，不稳定的排序算法是不能算正确的。

那么在往前看一看了解一下，是否是 es2018的 [Array.prototype.sort 规范](http://www.ecma-international.org/ecma-262/9.0/#sec-array.prototype.sort)有问题呢？

The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x < y, zero if x = y, or a positive value if x > y.

事实上，在 es2018 中仍旧没有要求 js引擎的数组排序算法是稳定的。所以据查阅 [资料](https://mathiasbynens.be/demo/sort-stability) 得到了目前主流浏览器中唯一具有不稳定的排序的是：Chakra。也就是微软自 IE9 以后所使用的引擎。


## Chakra 内部实现

## v8 内部实现



































































If comparefn is not undefined and IsCallable(comparefn) is false, throw a TypeError exception.
Let obj be ? ToObject(this value).
Let len be ? ToLength(? Get(obj, "length")).
Within this specification of the sort method, an object, obj, is said to be sparse if the following algorithm returns true:

For each integer i in the range 0 ≤ i < len, do
Let elem be obj.[[GetOwnProperty]](! ToString(i)).
If elem is undefined, return true.
Return false.
The sort order is the ordering, after completion of this function, of the integer-indexed property values of obj whose integer indexes are less than len. The result of the sort function is then determined as follows:

If comparefn is not undefined and is not a consistent comparison function for the elements of this array (see below), the sort order is implementation-defined. The sort order is also implementation-defined if comparefn is undefined and SortCompare does not act as a consistent comparison function.

Let proto be obj.[[GetPrototypeOf]](). If proto is not null and there exists an integer j such that all of the conditions below are satisfied then the sort order is implementation-defined:

obj is sparse
0 ≤ j < len
HasProperty(proto, ToString(j)) is true.
The sort order is also implementation-defined if obj is sparse and any of the following conditions are true:

IsExtensible(obj) is false.
Any integer index property of obj whose name is a nonnegative integer less than len is a data property whose [[Configurable]] attribute is false.
The sort order is also implementation-defined if any of the following conditions are true:

If obj is an exotic object (including Proxy exotic objects) whose behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]] is not the ordinary object implementation of these internal methods.
If any index property of obj whose name is a nonnegative integer less than len is an accessor property or is a data property whose [[Writable]] attribute is false.
If comparefn is undefined and the application of ToString to any value passed as an argument to SortCompare modifies obj or any object on obj's prototype chain.
If comparefn is undefined and all applications of ToString, to any specific value passed as an argument to SortCompare, do not produce the same result.
The following steps are taken:

Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:
The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.
The arguments for calls to SortCompare are values returned by a previous call to the [[Get]] internal method, unless the properties accessed by those previous calls did not exist according to HasOwnProperty. If both prospective arguments to SortCompare correspond to non-existent properties, use +0 instead of calling SortCompare. If only the first prospective argument is non-existent use +1. If only the second prospective argument is non-existent use -1.
If obj is not sparse then DeletePropertyOrThrow must not be called.
If any [[Set]] call returns false a TypeError exception is thrown.
If an abrupt completion is returned from any of these operations, it is immediately returned as the value of this function.
Return obj.
Unless the sort order is specified above to be implementation-defined, the returned object must have the following two characteristics:

There must be some mathematical permutation π of the nonnegative integers less than len, such that for every nonnegative integer j less than len, if property old[j] existed, then new[π(j)] is exactly the same value as old[j]. But if property old[j] did not exist, then new[π(j)] does not exist.
Then for all nonnegative integers j and k, each less than len, if SortCompare(old[j], old[k]) < 0 (see SortCompare below), then new[π(j)] < new[π(k)].
Here the notation old[j] is used to refer to the hypothetical result of calling obj.[[Get]](j) before this function is executed, and the notation new[j] to refer to the hypothetical result of calling obj.[[Get]](j) after this function has been executed.

A function comparefn is a consistent comparison function for a set of values S if all of the requirements below are met for all values a, b, and c (possibly the same value) in the set S: The notation a <CF b means comparefn(a, b) < 0; a =CF b means comparefn(a, b) = 0 (of either sign); and a >CF b means comparefn(a, b) > 0.

Calling comparefn(a, b) always returns the same value v when given a specific pair of values a and b as its two arguments. Furthermore, Type(v) is Number, and v is not NaN. Note that this implies that exactly one of a <CF b, a =CF b, and a >CF b will be true for a given pair of a and b.
Calling comparefn(a, b) does not modify obj or any object on obj's prototype chain.
a =CF a (reflexivity)
If a =CF b, then b =CF a (symmetry)
If a =CF b and b =CF c, then a =CF c (transitivity of =CF)
If a <CF b and b <CF c, then a <CF c (transitivity of <CF)
If a >CF b and b >CF c, then a >CF c (transitivity of >CF)
NOTE 1
The above conditions are necessary and sufficient to ensure that comparefn divides the set S into equivalence classes and that these equivalence classes are totally ordered.

NOTE 2
The sort function is intentionally generic; it does not require that its this value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.

